!Important ChatGPT Bing start!
!list of built in functions and description!

Name	Description
{ ... } (Block)	Blocks are one or more statements enclosed in braces. Typically used with function definitions and control flow statements.
{ ... } / Object	Creates an Object from a list of property name and value pairs.
[ ... ] / Array	Creates an Array from a sequence of parameter values.
Abs	Returns the absolute value of the specified number.
ASin	Returns the arcsine (the number whose sine is the specified number) in radians.
ACos	Returns the arccosine (the number whose cosine is the specified number) in radians.
ATan	Returns the arctangent (the number whose tangent is the specified number) in radians.
BlockInput	Disables or enables the user's ability to interact with the computer via keyboard and mouse.
Break	Exits (terminates) any type of loop statement.
Buffer	Creates a Buffer, which encapsulates a block of memory for use with other functions.
CallbackCreate	Creates a machine-code address that when called, redirects the call to a function in the script.
CallbackFree	Frees a callback created by CallbackCreate.
CaretGetPos	Retrieves the current position of the caret (text insertion point).
Catch	Specifies the code to execute if a value or error is thrown during execution of a Try statement.
Ceil	Returns the specified number rounded up to the nearest integer (without any .00 suffix).
Chr	Returns the string (usually a single character) corresponding to the character code indicated by the specified number.
Click	Clicks a mouse button at the specified coordinates. It can also hold down a mouse button, turn the mouse wheel, or move the mouse.
ClipboardAll	Creates an object containing everything on the clipboard (such as pictures and formatting).
ClipWait	Waits until the clipboard contains data.
ComCall	Calls a native COM interface method by index.
ComObjActive	Retrieves a registered COM object.
ComObjArray	Creates a SafeArray for use with COM.
ComObjConnect	Connects a COM object's event source to the script, enabling events to be handled.
ComObject	Creates a COM object.
ComObjFlags	Retrieves or changes flags which control a COM wrapper object's behaviour.
ComObjFromPtr	Wraps a raw IDispatch pointer (COM object) for use by the script.
ComObjGet	Returns a reference to an object provided by a COM component.
ComObjQuery	Queries a COM object for an interface or service.
ComObjType	Retrieves type information from a COM object.
ComObjValue	Retrieves the value or pointer stored in a COM wrapper object.
ComValue	Wraps a value, SafeArray or COM object for use by the script or for passing to a COM method.
Continue	Skips the rest of a loop statement's current iteration and begins a new one.
ControlAddItem	Adds the specified string as a new entry at the bottom of a ListBox or ComboBox.
ControlChooseIndex	Sets the selection in a ListBox, ComboBox or Tab control to be the specified entry or tab number.
ControlChooseString	Sets the selection in a ListBox or ComboBox to be the first entry whose leading part matches the specified string.
ControlClick	Sends a mouse button or mouse wheel event to a control.
ControlDeleteItem	Deletes the specified entry number from a ListBox or ComboBox.
ControlFindItem	Returns the entry number of a ListBox or ComboBox that is a complete match for the specified string.
ControlFocus	Sets input focus to a given control on a window.
ControlGetChecked	Returns a non-zero value if the checkbox or radio button is checked.
ControlGetChoice	Returns the name of the currently selected entry in a ListBox or ComboBox.
ControlGetClassNN	Returns the ClassNN (class name and sequence number) of the specified control.
ControlGetEnabled	Returns a non-zero value if the specified control is enabled.
ControlGetFocus	Retrieves which control of the target window has keyboard focus, if any.
ControlGetHwnd	Returns the unique ID number of the specified control.
ControlGetIndex	Returns the index of the currently selected entry or tab in a ListBox, ComboBox or Tab control.
ControlGetItems	Returns an array of items/rows from a ListBox, ComboBox, or DropDownList.
ControlGetPos	Retrieves the position and size of a control.
ControlGetStyle
ControlGetExStyle	Returns an integer representing the style or extended style of the specified control.
ControlGetText	Retrieves text from a control.
ControlGetVisible	Returns a non-zero value if the specified control is visible.
ControlHide	Hides the specified control.
ControlHideDropDown	Hides the drop-down list of a ComboBox control.
ControlMove	Moves or resizes a control.
ControlSend
ControlSendText	Sends simulated keystrokes or text to a window or control.
ControlSetChecked	Turns on (checks) or turns off (unchecks) a checkbox or radio button.
ControlSetEnabled	Enables or disables the specified control.
ControlSetStyle
ControlSetExStyle	Changes the style or extended style of the specified control, respectively.
ControlSetText	Changes the text of a control.
ControlShow	Shows the specified control if it was previously hidden.
ControlShowDropDown	Shows the drop-down list of a ComboBox control.
CoordMode	Sets coordinate mode for various built-in functions to be relative to either the active window or the screen.
Cos	Returns the trigonometric cosine of the specified number.
Critical	Prevents the current thread from being interrupted by other threads, or enables it to be interrupted.
DateAdd	Adds or subtracts time from a date-time value.
DateDiff	Compares two date-time values and returns the difference.
DetectHiddenText	Determines whether invisible text in a window is "seen" for the purpose of finding the window. This affects built-in functions such as WinExist and WinActivate.
DetectHiddenWindows	Determines whether invisible windows are "seen" by the script.
DirCopy	Copies a folder along with all its sub-folders and files (similar to xcopy).
DirCreate	Creates a folder.
DirDelete	Deletes a folder.
DirExist	Checks for the existence of a folder and returns its attributes.
DirMove	Moves a folder along with all its sub-folders and files. It can also rename a folder.
DirSelect	
Displays a standard dialog that allows the user to select a folder.

DllCall	Calls a function inside a DLL, such as a standard Windows API function.
Download	Downloads a file from the Internet.
DriveEject	Ejects the tray of the specified CD/DVD drive, or ejects a removable drive.
DriveGetCapacity	Returns the total capacity of the drive which contains the specified path, in megabytes.
DriveGetFileSystem	Returns the type of the specified drive's file system.
DriveGetLabel	Returns the volume label of the specified drive.
DriveGetList	Returns a string of letters, one character for each drive letter in the system.
DriveGetSerial	Returns the volume serial number of the specified drive.
DriveGetSpaceFree	Returns the free disk space of the drive which contains the specified path, in megabytes.
DriveGetStatus	Returns the status of the drive which contains the specified path.
DriveGetStatusCD	Returns the media status of the specified CD/DVD drive.
DriveGetType	Returns the type of the drive which contains the specified path.
DriveLock	Prevents the eject feature of the specified drive from working.
DriveRetract	Retracts the tray of the specified CD/DVD drive.
DriveSetLabel	Changes the volume label of the specified drive.
DriveUnlock	Restores the eject feature of the specified drive.
Edit	Opens the current script for editing in the default editor.
EditGetCurrentCol	Returns the column number in an Edit control where the caret (text insertion point) resides.
EditGetCurrentLine	Returns the line number in an Edit control where the caret (text insert point) resides.
EditGetLine	Returns the text of the specified line in an Edit control.
EditGetLineCount	Returns the number of lines in an Edit control.
EditGetSelectedText	Returns the selected text in an Edit control.
EditPaste	Pastes the specified string at the caret (text insertion point) in an Edit control.
Else	Specifies one or more statements to execute if the associated statement's body did not execute.
EnvGet	Retrieves an environment variable.
EnvSet	Writes a value to a variable contained in the environment.
Exit	Exits the current thread.
ExitApp	Terminates the script.
Exp	Returns e (which is approximately 2.71828182845905) raised to the Nth power.
FileAppend	Writes text or binary data to the end of a file (first creating the file, if necessary).
FileCopy	Copies one or more files.
FileCreateShortcut	Creates a shortcut (.lnk) file.
FileDelete	Deletes one or more files.
FileEncoding	Sets the default encoding for FileRead, Loop Read, FileAppend, and FileOpen.
FileExist	Checks for the existence of a file or folder and returns its attributes.
FileInstall	Includes the specified file inside the compiled version of the script.
FileGetAttrib	Reports whether a file or folder is read-only, hidden, etc.
FileGetShortcut	Retrieves information about a shortcut (.lnk) file, such as its target file.
FileGetSize	Retrieves the size of a file.
FileGetTime	Retrieves the datetime stamp of a file or folder.
FileGetVersion	Retrieves the version of a file.
FileMove	Moves or renames one or more files.
FileOpen	Opens a file to read specific content from it and/or to write new content into it.
FileRead	Retrieves the contents of a file.
FileRecycle	Sends a file or directory to the recycle bin if possible, or permanently deletes it.
FileRecycleEmpty	Empties the recycle bin.
FileSelect	Displays a standard dialog that allows the user to open or save file(s).
FileSetAttrib	Changes the attributes of one or more files or folders. Wildcards are supported.
FileSetTime	Changes the datetime stamp of one or more files or folders. Wildcards are supported.
Finally	Ensures that one or more statements are always executed after a Try statement finishes.
Float	Converts a numeric string or integer value to a floating-point number.
Floor	Returns the specified number rounded down to the nearest integer (without any .00 suffix).
For	Repeats one or more statements once for each key-value pair in an object.
Format	Formats a variable number of input values according to a format string.
FormatTime	Transforms a YYYYMMDDHH24MISS timestamp into the specified date/time format.
GetKeyName	Retrieves the name/text of a key.
GetKeyVK	Retrieves the virtual key code of a key.
GetKeySC	Retrieves the scan code of a key.
GetKeyState	Checks if a keyboard key or mouse/controller button is down or up. Also retrieves controller status.
GetMethod	Retrieves the implementation function of a method.
Goto	Jumps to the specified label and continues execution.
GroupActivate	Activates the next window in a window group that was defined with GroupAdd.
GroupAdd	Adds a window specification to a window group, creating the group if necessary.
GroupClose	Closes the active window if it was just activated by GroupActivate or GroupDeactivate. It then activates the next window in the series. It can also close all windows in a group.
GroupDeactivate	Similar to GroupActivate except activates the next window not in the group.
Gui()	Creates and returns a new Gui object. This can be used to define a custom window, or graphical user interface (GUI), to display information or accept user input.
GuiCtrlFromHwnd	Retrieves the GuiControl object of a GUI control associated with the specified HWND.
GuiFromHwnd	Retrieves the Gui object of a GUI window associated with the specified HWND.
HasBase	Returns a non-zero number if the specified value is derived from the specified base object.
HasMethod	Returns a non-zero number if the specified value has a method by the specified name.
HasProp	Returns a non-zero number if the specified value has a property by the specified name.
HotIf / HotIfWin...	Specifies the criteria for subsequently created or modified hotkey variants.
Hotkey	Creates, modifies, enables, or disables a hotkey while the script is running.
Hotstring	Creates, modifies, enables, or disables a hotstring while the script is running.
If	Specifies one or more statements to execute if an expression evaluates to true.
IL_Create
IL_Add
IL_Destroy	The means by which icons are added to a ListView or TreeView control.
ImageSearch	Searches a region of the screen for an image.
IniDelete	Deletes a value from a standard format .ini file.
IniRead	Reads a value, section or list of section names from a standard format .ini file.
IniWrite	Writes a value or section to a standard format .ini file.
InputBox	Displays an input box to ask the user to enter a string.
InputHook	Creates an object which can be used to collect or intercept keyboard input.
InstallKeybdHook	Installs or uninstalls the keyboard hook.
InstallMouseHook	Installs or uninstalls the mouse hook.
InStr	Searches for a given occurrence of a string, from the left or the right.
Integer	Converts a numeric string or floating-point value to an integer.
IsLabel	Returns a non-zero number if the specified label exists in the current scope.
IsObject	Returns a non-zero number if the specified value is an object.
IsSet / IsSetRef	Returns a non-zero number if the specified variable has been assigned a value.
KeyHistory	Displays script info and a history of the most recent keystrokes and mouse clicks.
KeyWait	Waits for a key or mouse/controller button to be released or pressed down.
ListHotkeys	Displays the hotkeys in use by the current script, whether their subroutines are currently running, and whether or not they use the keyboard or mouse hook.
ListLines	Enables or disables line logging or displays the script lines most recently executed.
ListVars	Displays the script's variables: their names and current contents.
ListViewGetContent	Returns a list of items/rows from a ListView.
LoadPicture	Loads a picture from file and returns a bitmap or icon handle.
Log	Returns the logarithm (base 10) of the specified number.
Ln	Returns the natural logarithm (base e) of the specified number.
Loop (normal)	Performs one or more statements repeatedly: either the specified number of times or until Break is encountered.
Loop Files	Retrieves the specified files or folders, one at a time.
Loop Parse	Retrieves substrings (fields) from a string, one at a time.
Loop Read	Retrieves the lines in a text file, one at a time.
Loop Reg	Retrieves the contents of the specified registry subkey, one item at a time.
Map	Creates a Map from a list of key-value pairs.
Max	Returns the highest number from a set of numbers.
MenuBar()	Creates a MenuBar object, which can be used to define a GUI menu bar.
Menu()	Creates a Menu object, which can be used to create and display a menu.
MenuFromHandle	Retrieves the Menu or MenuBar object corresponding to a Win32 menu handle.
MenuSelect	Invokes a menu item from the menu bar of the specified window.
Min	Returns the lowest number from a set of numbers.
Mod	Modulo. Returns the remainder of the specified dividend divided by the specified divisor.
MonitorGet	Checks if the specified monitor exists and optionally retrieves its bounding coordinates.
MonitorGetCount	Returns the total number of monitors.
MonitorGetName	Returns the operating system's name of the specified monitor.
MonitorGetPrimary	Returns the number of the primary monitor.
MonitorGetWorkArea	Checks if the specified monitor exists and optionally retrieves the bounding coordinates of its working area.
MouseClick	Clicks or holds down a mouse button, or turns the mouse wheel. Note: The Click function is generally more flexible and easier to use.
MouseClickDrag	Clicks and holds the specified mouse button, moves the mouse to the destination coordinates, then releases the button.
MouseGetPos	Retrieves the current position of the mouse cursor, and optionally which window and control it is hovering over.
MouseMove	Moves the mouse cursor.
MsgBox	Displays the specified text in a small window containing one or more buttons (such as Yes and No).
Number	Converts a numeric string to a pure integer or floating-point number.
NumGet	Returns the binary number stored at the specified address+offset.
NumPut	Stores one or more numbers in binary format at the specified address+offset.
ObjAddRef / ObjRelease	Increments or decrements an object's reference count.
ObjBindMethod	Creates a BoundFunc object which calls a method of a given object.
ObjHasOwnProp
ObjOwnProps
These functions are equivalent to built-in methods of the Object type. It is usually recommended to use the corresponding method instead.
ObjGetBase	Retrieves an object's base object.
ObjGetCapacity	Returns the current capacity of the object's internal array of properties.
ObjOwnPropCount	Returns the number of properties owned by an object.
ObjSetBase	Sets an object's base object.
ObjSetCapacity	Sets the current capacity of the object's internal array of own properties.
OnClipboardChange	Causes the specified function to be called automatically whenever the clipboard's content changes.
OnError	Causes the specified function to be called automatically when an unhandled error occurs.
OnExit	Causes the specified function to be called automatically when the script exits.
OnMessage	Causes the specified function to be called automatically whenever the script receives the specified message.
Ord	Returns the ordinal value (numeric character code) of the first character in the specified string.
OutputDebug	Sends a string to the debugger (if any) for display.
Pause	Pauses the script's current thread.
Persistent	Prevents the script from exiting automatically when its last thread completes, allowing it to stay running in an idle state.
PixelGetColor	Retrieves the color of the pixel at the specified x,y coordinates.
PixelSearch	Searches a region of the screen for a pixel of the specified color.
PostMessage	Places a message in the message queue of a window or control.
ProcessClose	Forces the first matching process to close.
ProcessExist	Checks if the specified process exists.
ProcessGetName	Returns the name of the specified process.
ProcessGetParent	Returns the process ID (PID) of the process which created the specified process.
ProcessGetPath	Returns the path of the specified process.
ProcessSetPriority	Changes the priority level of the first matching process.
ProcessWait	Waits for the specified process to exist.
ProcessWaitClose	Waits for all matching processes to close.
Random	Generates a pseudo-random number.
RegExMatch	Determines whether a string contains a pattern (regular expression).
RegExReplace	Replaces occurrences of a pattern (regular expression) inside a string.
RegCreateKey	Creates a registry key without writing a value.
RegDelete	Deletes a value from the registry.
RegDeleteKey	Deletes a subkey from the registry.
RegRead	Reads a value from the registry.
RegWrite	Writes a value to the registry.
Reload	Replaces the currently running instance of the script with a new one.
Return	Returns from a subroutine to which execution had previously jumped via function-call, Hotkey activation, or other means.
Round	Returns the specified number rounded to N decimal places.
Run	Runs an external program.
RunAs	Specifies a set of user credentials to use for all subsequent uses of Run and RunWait.
RunWait	Runs an external program and waits until it finishes.
Send / SendText / SendInput / SendPlay / SendEvent	Sends simulated keystrokes and mouse clicks to the active window.
SendLevel	Controls which artificial keyboard and mouse events are ignored by hotkeys and hotstrings.
SendMessage	Sends a message to a window or control and waits for acknowledgement.
SendMode	Makes Send synonymous with SendEvent or SendPlay rather than the default (SendInput). Also makes Click and MouseMove/Click/Drag use the specified method.
SetCapsLockState	Sets the state of CapsLock. Can also force the key to stay on or off.
SetControlDelay	Sets the delay that will occur after each control-modifying function.
SetDefaultMouseSpeed	Sets the mouse speed that will be used if unspecified in Click and MouseMove/Click/Drag.
SetKeyDelay	Sets the delay that will occur after each keystroke sent by Send or ControlSend.
SetMouseDelay	Sets the delay that will occur after each mouse movement or click.
SetNumLockState	Sets the state of NumLock. Can also force the key to stay on or off.
SetScrollLockState	Sets the state of ScrollLock. Can also force the key to stay on or off.
SetRegView	Sets the registry view used by RegRead, RegWrite, RegDelete, RegDeleteKey and Loop Reg, allowing them in a 32-bit script to access the 64-bit registry view and vice versa.
SetStoreCapsLockMode	Whether to restore the state of CapsLock after a Send.
SetTimer	Causes a function to be called automatically and repeatedly at a specified time interval.
SetTitleMatchMode	Sets the matching behavior of the WinTitle parameter in built-in functions such as WinWait.
SetWinDelay	Sets the delay that will occur after each windowing function, such as WinActivate.
SetWorkingDir	Changes the script's current working directory.
Shutdown	Shuts down, restarts, or logs off the system.
Sin	Returns the trigonometric sine of the specified number.
Sleep	Waits the specified amount of time before continuing.
Sort	Arranges a variable's contents in alphabetical, numerical, or random order (optionally removing duplicates).
SoundBeep	Emits a tone from the PC speaker.
SoundGetInterface	Retrieves a native COM interface of a sound device or component.
SoundGetMute	Retrieves a mute setting of a sound device.
SoundGetName	Retrieves the name of a sound device or component.
SoundGetVolume	Retrieves a volume setting of a sound device.
SoundPlay	Plays a sound, video, or other supported file type.
SoundSetMute	Changes a mute setting of a sound device.
SoundSetVolume	Changes a volume setting of a sound device.
SplitPath	Separates a file name or URL into its name, directory, extension, and drive.
Sqrt	Returns the square root of the specified number.
StatusBarGetText	Retrieves the text from a standard status bar control.
StatusBarWait	Waits until a window's status bar contains the specified string.
StrCompare	Compares two strings alphabetically.
StrGet	Copies a string from a memory address or buffer, optionally converting it from a given code page.
String	Converts a value to a string.
StrLen	Retrieves the count of how many characters are in a string.
StrLower	Converts a string to lowercase.
StrPtr	Returns the current memory address of a string.
StrPut	Copies a string to a memory address or buffer, optionally converting it to a given code page.
StrReplace	Replaces the specified substring with a new string.
StrSplit	Separates a string into an array of substrings using the specified delimiters.
StrUpper	Converts a string to uppercase.
SubStr	Retrieves one or more characters from the specified position in a string.
Suspend	Disables or enables all or selected hotkeys and hotstrings.
Switch	Executes one case from a list of mutually exclusive candidates.
SysGet	Retrieves dimensions of system objects, and other system properties.
SysGetIPAddresses	Returns an array of the system's IPv4 addresses.
Tan	Returns the trigonometric tangent of the specified number.
Thread	Sets the priority or interruptibility of threads. It can also temporarily disable all timers.
Throw	Signals the occurrence of an error. This signal can be caught by a Try-Catch statement.
ToolTip	Creates an always-on-top window anywhere on the screen.
TraySetIcon	Changes the script's tray icon (which is also used by GUI and dialog windows).
TrayTip	Creates a balloon message window near the tray icon. On Windows 10, a toast notification may be shown instead.
Trim / LTrim / RTrim	Trims characters from the beginning and/or end of a string.
Try	Guards one or more statements against runtime errors and values thrown by the Throw statement.
Type	Returns the class name of a value.
Until	Applies a condition to the continuation of a Loop or For-loop.
VarSetStrCapacity	Enlarges a variable's holding capacity or frees its memory. This is not normally needed, but may be used with DllCall or SendMessage or to optimize repeated concatenation.
VerCompare	Compares two version strings.
While-loop	Performs one or more statements repeatedly until the specified expression evaluates to false.
WinActivate	Activates the specified window.
WinActivateBottom	Same as WinActivate except that it activates the bottommost matching window rather than the topmost.
WinActive	Checks if the specified window is active and returns its unique ID (HWND).
WinClose	Closes the specified window.
WinExist	Checks if the specified window exists and returns the unique ID (HWND) of the first matching window.
WinGetClass	Retrieves the specified window's class name.
WinGetClientPos	Retrieves the position and size of the specified window's client area.
WinGetControls	Returns the control names for all controls in the specified window.
WinGetControlsHwnd	Returns the unique ID numbers for all controls in the specified window.
WinGetCount	Returns the number of existing windows that match the specified criteria.
WinGetID	Returns the unique ID number of the specified window.
WinGetIDLast	Returns the unique ID number of the last/bottommost window if there is more than one match.
WinGetList	Returns the unique ID numbers of all existing windows that match the specified criteria.
WinGetMinMax	Returns the state whether the specified window is maximized or minimized.
WinGetPID	Returns the Process ID number of the specified window.
WinGetPos	Retrieves the position and size of the specified window.
WinGetProcessName	Returns the name of the process that owns the specified window.
WinGetProcessPath	Returns the full path and name of the process that owns the specified window.
WinGetStyle
WinGetExStyle	Returns the style or extended style (respectively) of the specified window.
WinGetText	Retrieves the text from the specified window.
WinGetTitle	Retrieves the title of the specified window.
WinGetTransColor	Returns the color that is marked transparent in the specified window.
WinGetTransparent	Returns the degree of transparency of the specified window.
WinHide	Hides the specified window.
WinKill	Forces the specified window to close.
WinMaximize	Enlarges the specified window to its maximum size.
WinMinimize	Collapses the specified window into a button on the task bar.
WinMinimizeAll / WinMinimizeAllUndo	Minimizes or unminimizes all windows.
WinMove	Changes the position and/or size of the specified window.
WinMoveBottom	Sends the specified window to the bottom of stack; that is, beneath all other windows.
WinMoveTop	Brings the specified window to the top of the stack without explicitly activating it.
WinRedraw	Redraws the specified window.
WinRestore	Unminimizes or unmaximizes the specified window if it is minimized or maximized.
WinSetAlwaysOnTop	Makes the specified window stay on top of all other windows (except other always-on-top windows).
WinSetEnabled	Enables or disables the specified window.
WinSetRegion	Changes the shape of the specified window to be the specified rectangle, ellipse, or polygon.
WinSetStyle
WinSetExStyle	Changes the style or extended style of the specified window, respectively.
WinSetTitle	Changes the title of the specified window.
WinSetTransColor	Makes all pixels of the chosen color invisible inside the specified window.
WinSetTransparent	Makes the specified window semi-transparent.
WinShow	Unhides the specified window.
WinWait	Waits until the specified window exists.
WinWaitActive / WinWaitNotActive	Waits until the specified window is active or not active.
WinWaitClose	Waits until no matching windows can be found.
#ClipboardTimeout	Changes how long the script keeps trying to access the clipboard when the first attempt fails.
#DllLoad	Loads a DLL or EXE file before the script starts executing.
#ErrorStdOut	Sends any syntax error that prevents a script from launching to the standard error stream (stderr) rather than displaying a dialog.
#Hotstring	Changes hotstring options or ending characters.
#HotIf	Creates context-sensitive hotkeys and hotstrings. Such hotkeys perform a different action (or none at all) depending on any condition (an expression).
#HotIfTimeout	Sets the maximum time that may be spent evaluating a single #HotIf expression.
#Include / #IncludeAgain	Causes the script to behave as though the specified file's contents are present at this exact position.
#InputLevel	Controls which artificial keyboard and mouse events are ignored by hotkeys and hotstrings.
#MaxThreads	Sets the maximum number of simultaneous threads.
#MaxThreadsBuffer	Causes some or all hotkeys to buffer rather than ignore keypresses when their #MaxThreadsPerHotkey limit has been reached.
#MaxThreadsPerHotkey	Sets the maximum number of simultaneous threads per hotkey or hotstring.
#NoTrayIcon	Disables the showing of a tray icon.
#Requires	Displays an error and quits if a version requirement is not met.
#SingleInstance	Determines whether a script is allowed to run again when it is already running.
#SuspendExempt	Exempts subsequent hotkeys and hotstrings from suspension.
#UseHook	Forces the use of the hook to implement all or some keyboard hotkeys.
#Warn	Enables or disables warnings for specific conditions which may indicate an error, such as a typo or missing "global" declaration.
#WinActivateForce	Skips the gentle method of activating a window and goes straight to the forceful method.

!Important ChatGPT Bing end!
!list of built in functions and description!


!Important ChatGPT Bing start!
!functions from "autohotkey v1" that are no longer valid!


functions from "autohotkey v1" that are no longer valid:::::
Asc() (use Ord)
AutoTrim (use Trim)
ComObjMissing() (write two consecutive commas instead)
ComObjUnwrap() (use ComObjValue instead, and ObjAddRef if needed)
ComObjEnwrap() (use ComObjFromPtr instead, and ObjAddRef if needed)
ComObjError()
ComObjXXX() where XXX is anything other than one of the explicitly defined ComObj functions (use ComObjActive, ComValue or ComObjFromPtr instead).
ControlSendRaw (use ControlSend "{Raw}" or ControlSendText instead)
EnvDiv
EnvMult
EnvUpdate (it is of very limited usefulness and can be replaced with a simple SendMessage)
Exception (use Error or an appropriate subclass)
FileReadLine (use a file-reading loop or FileOpen)
Func (use a direct reference like MyFunc)
Gosub
Gui, GuiControl, GuiControlGet (see Gui)
IfEqual
IfExist
IfGreater
IfGreaterOrEqual
IfInString
IfLess
IfLessOrEqual
IfMsgBox (MsgBox now returns the button name)
IfNotEqual
IfNotExist
IfNotInString
IfWinActive
IfWinExist
IfWinNotActive
IfWinNotExist
If between/is/in/contains (but see isXXX)
Input (use InputHook)
IsFunc
Menu (use the Menu/MenuBar class, TraySetIcon, A_IconTip, A_IconHidden and A_AllowMainWindow)
MenuGetHandle (use Menu.Handle)
MenuGetName (there are no menu names; MenuFromHandle is the closest replacement)
Progress (use Gui)
SendRaw (use Send "{Raw}" or SendText instead)
SetBatchLines (-1 is now the default behaviour)
SetEnv
SetFormat (Format can be used to format a string)
SoundGet/SoundSet (see Sound functions)
SoundGetWaveVolume/SoundSetWaveVolume (slightly different behaviour to SoundGet/SoundSet regarding balance, but neither one preserves balance)
SplashImage (use Gui)
SplashTextOn/Off (use Gui)
StringCaseSense (use various parameters)
StringGetPos (use InStr)
StringLeft
StringLen
StringMid
StringRight
StringTrimLeft
StringTrimRight -- use SubStr in place of these commands.
StringReplace (use StrReplace instead)
StringSplit (use StrSplit instead)
Transform
VarSetCapacity (use a Buffer object for binary data/structs and VarSetStrCapacity for UTF-16 strings)
WinGetActiveStats
WinGetActiveTitle
#CommentFlag
#Delimiter
#DerefChar
#EscapeChar
#HotkeyInterval (use A_HotkeyInterval)
#HotkeyModifierTimeout (use A_HotkeyModifierTimeout)
#IfWinActive, #IfWinExist, #IfWinNotActive, #IfWinNotExist (see #HotIf Optimization)
#InstallKeybdHook (use the InstallKeybdHook function)
#InstallMouseHook (use the InstallMouseHook function)
#KeyHistory (use KeyHistory N)
#LTrim
#MaxHotkeysPerInterval (use A_MaxHotkeysPerInterval)
#MaxMem (maximum capacity of each variable is now unlimited)
#MenuMaskKey (use A_MenuMaskKey)
#NoEnv (now default behaviour)
Renamed:

ComObjCreate() → ComObject, which is a class now
ComObjParameter() → ComValue, which is a class now
DriveSpaceFree → DriveGetSpaceFree
EnvAdd → DateAdd
EnvSub → DateDiff
FileCopyDir → DirCopy
FileCreateDir → DirCreate
FileMoveDir → DirMove
FileRemoveDir → DirDelete
FileSelectFile → FileSelect
FileSelectFolder → DirSelect
#If → #HotIf
#IfTimeout → HotIfTimeout
StringLower → StrLower and StrTitle
StringUpper → StrUpper and StrTitle
UrlDownloadToFile → Download
WinMenuSelectItem → MenuSelect
LV, TV and SB functions → methods of GuiControl
File.__Handle → File.Handle
Removed Commands (Details)
See above for the full list.

EnvUpdate was removed, but can be replaced with a simple call to SendMessage as follows:

SendMessage(0x1A, 0, StrPtr("Environment"), 0xFFFF)
 
Modified Commands/Functions
 
 
 
ComObj():   
FileCopy and FileMove now throw an exception if the source path does not contain * or ? and no file was not found. However, it is still not considered an error to copy or move zero files when the source path contains wildcards.

FileOpen now throws an exception if it fails to open the file. Otherwise, an exception would be thrown (if the script didn't check for failure) by the first attempt to access the object, rather than at the actual point of failure.

File.RawRead: When a variable is passed directly, the address of the variable's internal string buffer is no longer used. Therefore, a variable containing an address may be passed directly (whereas in v1, something like var+0 was necessary).

For buffers allocated by the script, the new Buffer object is preferred over a variable; any object can be used, but must have Ptr and Size properties.

File.RawWrite: As above, except that it can accept a string (or variable containing a string), in which case Bytes defaults to the size of the string in bytes. The string may contain binary zero.

File.ReadLine now always supports `r, `n and `r`n as line endings, and no longer includes the line ending in the return value. Line endings are still returned to the script as-is by File.Read if EOL translation is not enabled.

FileEncoding now allows code pages to be specified by number without the CP prefix. Its parameter is no longer optional, but can still be explicitly blank.

FileExist now ignores the . and .. implied in every directory listing, so FileExist("dir\*") is now false instead of true when dir exists but is empty.

FileGetAttrib and A_LoopFileAttrib now include the letter "L" for reparse points or symbolic links.

FileInstall in a non-compiled script no longer attempts to copy the file if source and destination are the same path (after resolving relative paths, as the source is relative to A_ScriptDir, not A_WorkingDir). In v1 this caused ErrorLevel to be set to 1, which mostly went unnoticed. Attempting to copy a file onto itself via two different paths still causes an error.

FileSelectFile (now named FileSelect) had two multi-select modes, accessible via options 4 and M. Option 4 and the corresponding mode have been removed; they had been undocumented for some time. FileSelect now returns an Array of paths when the multi-select mode is used, instead of a string like C:\Dir`nFile1`nFile2. Each array element contains the full path of a file. If the user cancels, the array is empty.

FileSelect now uses the IFileDialog API present in Windows Vista and later, instead of the old GetOpenFileName/GetSaveFileName API. This removes the need for (built-in) workarounds relating to the dialog changing the current working directory.

FileSelect no longer has a redundant "Text Documents (*.txt)" filter by default when Filter is omitted.

FileSelect no longer strips spaces from the filter pattern, such as for pattern with spaces*.ext. Testing indicates spaces on either side of the pattern (such as after the semi-colon in *.cpp; *.h) are already ignored by the OS, so there should be no negative consequences.

FileSelect can now be used in "Select Folder" mode via the D option letter.

FileSetAttrib now overwrites attributes when no +, - or ^ prefix is present, instead of doing nothing. For example, FileSetAttrib(FileGetAttrib(file2), file1) copies the attributes of file2 to file1 (adding any that file2 have and removing any that it does not have).

FileSetAttrib and FileSetTime: the OperateOnFolders? and Recurse? parameters have been replaced with a single Mode parameter identical to that of Loop Files. For example, FileSetAttrib("+a", "*.zip", "RF") (Recursively operate on Files only).

GetKeyName now returns the non-Numpad names for VK codes that correspond to both a Numpad and a non-Numpad key. For instance, GetKeyName("vk25") returns Left instead of NumpadLeft.

GetKeyState now always returns 0 or 1.

GroupActivate now returns the HWND of the window which was selected for activation, or 0 if there were no matches (aside from the already-active window), instead of setting ErrorLevel.

GroupAdd: Removed the Label parameter and related functionality. This was an unintuitive way to detect when GroupActivate fails to find any matching windows; GroupActivate's return value should be used instead.

GroupDeactivate now selects windows in a manner closer to the Alt+Esc and Alt+Shift+Esc system hotkeys and the taskbar. Specifically,

Owned windows are not evaluated. If the owner window is eligible (not a match for the group), either the owner window or one of its owned windows is activated; whichever was active last. A window owned by a group member will no longer be activated, but adding the owned window itself to the group now has no effect. (The previous behaviour was to cycle through every owned window and never activate the owner.)
Any disabled window is skipped, unless one of its owned windows was active more recently than it.
Windows with the WS_EX_NOACTIVATE style are skipped, since they are probably not supposed to be activated. They are also skipped by the Alt+Esc and Alt+Shift+Esc system hotkeys.
Windows with WS_EX_TOOLWINDOW but not WS_EX_APPWINDOW are omitted from the taskbar and Alt-Tab, and are therefore skipped.
Hotkey no longer defaults to the script's bottommost #HotIf (formerly #If). Hotkey/hotstring and HotIf threads default to the same criterion as the hotkey, so Hotkey A_ThisHotkey, "Off" turns off the current hotkey even if it is context-sensitive. All other threads default to the last setting used by the auto-execute section, which itself defaults to no criterion (global hotkeys).

Hotkey's Callback parameter now requires a function object or hotkey name. Labels and function names are no longer supported. If a hotkey name is specified, the original function of that hotkey is used; and unlike before, this works with #HotIf (formerly #If).

Among other benefits, this eliminates ambiguity with the following special strings: On, Off, Toggle, AltTab, ShiftAltTab, AltTabAndMenu, AltTabMenuDismiss. The old behaviour was to use the label/function by that name if one existed, but only if the Label parameter did not contain a variable reference or expression.
Hotkey and Hotstring now support the S option to make the hotkey/hostring exempt from Suspend (equivalent to the new #SuspendExempt directive), and the S0 option to disable exemption.

"Hotkey If" and the other If sub-commands were replaced with individual functions: HotIf, HotIfWinActive, HotIfWinExist, HotIfWinNotActive, HotIfWinNotExist.

HotIf (formerly "Hotkey If") now recognizes expressions which use the and or or operators. This did not work in v1 as these operators were replaced with && or || at load time.

Hotkey no longer has a UseErrorLevel option, and never sets ErrorLevel. An exception is thrown on failure. Error messages were changed to be constant (and shorter), with the key or hotkey name in Exception.Extra, and the class of the exception indicating the reason for failure.

#HotIf (formerly #If) now implicitly creates a function with one parameter (ThisHotkey). As is the default for all functions, this function is assume-local. The expression can create local variables and read global variables, but cannot directly assign to global variables as the expression cannot contain declarations.
 
KeyHistory N resizes the key history buffer instead of displaying the key history. This replaces "#KeyHistory N".

ImageSearch returns true if the image was found, false if it was not found, or throws an exception if the search could not be conducted. ErrorLevel is not set.

IniDelete, IniRead and IniWrite set A_LastError to the result of the operating system's GetLastError() function.

IniRead throws an exception if the requested key, section or file cannot be found and the Default parameter was omitted. If Default is given a value, even "", no exception is thrown.

InputHook now treats Shift+Backspace the same as Backspace, instead of transcribing it to `b.

InputBox has been given a syntax overhaul to make it easier to use (with fewer parameters). See InputBox for usage.

InStr's CaseSensitive parameter has been replaced with CaseSense, which can be 0, 1 or "Locale".
 
MouseClick and MouseClickDrag are no longer affected by the system setting for swapped mouse buttons; "Left" is the always the primary button and "Right" is the secondary.

MsgBox has had its syntax changed to prioritise its most commonly used parameters and improve ease of use. See MsgBox further below for a summary of usage.
 
The use of Object(obj) and Object(ptr) to convert between a reference and a pointer was shifted to separate functions, ObjPtrAddRef(obj) and ObjFromPtrAddRef(ptr). There are also versions of these functions that do not increment the reference count: ObjPtr(obj) and ObjFromPtr(ptr).

The OnClipboardChange label is no longer called automatically if it exists. Use the OnClipboardChange function which was added in v1.1.20 instead. It now requires a function object, not a name.

OnError now requires a function object, not a name. See also Error Handling further below.
  

When KeyName is omitted and the current loop reg item is a subkey, RegDelete, RegRead and RegWrite now operate on values within that subkey; i.e. KeyName defaults to A_LoopRegKey "\" A_LoopRegName in that case (note that A_LoopRegKey was merged with A_LoopRegSubKey). Previously they behaved as follows:

RegRead read a value with the same name as the subkey, if one existed in the parent key.
RegWrite returned an error.
RegDelete deleted the subkey.
RegDelete, RegRead and RegWrite now allow ValueName to be specified when KeyName is omitted:

If the current loop reg item is a subkey, ValueName defaults to empty (the subkey's default value) and ValueType must be specified.
If the current loop reg item is a value, ValueName and ValueType default to that value's name and type, but one or both can be overridden.
Otherwise, RegDelete with a blank or omitted ValueName now deletes the key's default value (not the key itself), for consistency with RegWrite, RegRead and A_LoopRegName. The phrase "AHK_DEFAULT" no longer has any special meaning. To delete a key, use RegDeleteKey (new).

RegRead now has a Default parameter, like IniRead.

RegRead had an undocumented 5-parameter mode, where the value type was specified after the output variable. This has been removed.

Reload now does nothing if the script was read from stdin.

Run and RunWait no longer recognize the UseErrorLevel option as ErrorLevel was removed. Use try/catch instead. A_LastError is set unconditionally, and can be inspected after an exception is caught/suppressed. RunWait returns the exit code.

Send (and its variants) now interpret {LButton} and {RButton} in a way consistent with hotkeys and Click. That is, LButton is the primary button and RButton is the secondary button, even if the user has swapped the buttons via system settings.

SendMessage and PostMessage now require wParam and lParam to be integers or objects with a Ptr property; an exception is thrown if they are given a non-numeric string or float. Previously a string was passed by address if the expression began with ", but other strings were coerced to integers. Passing the address of a variable (formerly &var, now StrPtr(var)) no longer updates the variable's length (use VarSetStrCapacity(&var, -1)).

SendMessage and PostMessage now throw an exception on failure (or timeout) and do not set ErrorLevel. SendMessage returns the message reply.

SetTimer no longer supports label or function names, but as it now accepts an expression and functions can be referenced directly by name, usage looks very similar: SetTimer MyFunc. As with all other functions which accept an object, SetTimer now allows expressions which return an object (previously it required a variable reference).

Sort has received the following changes:

The VarName parameter has been split into separate input/output parameters, for flexibility. Usage is now Output := Sort(Input [, Options, Function]).
When any two items compare equal, the original order of the items is now automatically used as a tie-breaker to ensure more stable results.
The C option now also accepts a suffix equivalent to the CaseSense parameter of other functions (in addition to CL): CLocale CLogical COn C1 COff C0. In particular, support for the "logical" comparison mode is new.
Sound functions: SoundGet and SoundSet have been revised to better match the capabilities of the Vista+ sound APIs, dropping support for XP.
 
StrGet: If Length is negative, its absolute value indicates the exact number of characters to convert, including any binary zeros that the string might contain -- in other words, the result is always a string of exactly that length. If Length is positive, the converted string ends at the first binary zero as in v1.

StrGet/StrPut: The Address parameter can be an object with the Ptr and Size properties, such as the new Buffer object. The read/write is automatically limited by Size (which is in bytes). If Length is also specified, it must not exceed Size (multiplied by 2 for UTF-16).

StrPut's return value is now in bytes, so it can be passed directly to Buffer().

StrReplace now has a CaseSense parameter in place of OutputVarCount, which is moved one parameter to the right, with Limit following it.

Suspend: Making a hotkey or hotstring's first line a call to Suspend no longer automatically makes it exempt from suspension. Instead, use #SuspendExempt or the S option. The "Permit" parameter value is no longer valid.

Switch now performs case-sensitive comparison for strings by default, and has a CaseSense parameter which overrides the mode of case sensitivity and forces string (rather than numeric) comparison. Previously it was case-sensitive only if StringCaseSense was changed to On.

SysGet now only has numeric sub-commands; its other sub-commands have been split into functions. See Sub-Commands further below for details.
 
#Warn UseUnsetLocal and UseUnsetGlobal have been removed, as reading an unset variable now raises an error. IsSet can be used to avoid the error and try/catch or OnError can be used to handle it.

#Warn VarUnset was added; it defaults to MsgBox. If not disabled, a warning is given for the first non-dynamic reference to each variable which is never used as the target of a direct, non-dynamic assignment or the reference operator (&), or passed directly to IsSet.

#Warn Unreachable no longer considers lines following an Exit call to be unreachable, as Exit is now an ordinary function.

#Warn ClassOverwrite has been removed, as top-level classes can no longer be overwritten by assignment. (However, they can now be implicitly shadowed by a local variable; that can be detected by #Warn LocalSameAsGlobal.)

WinActivate now sends {Alt up} after its first failed attempt at activating a window. Testing has shown this reduces the occurrence of flashing taskbar buttons. See the documentation for more details.

WinSetTitle and WinMove now use parameter order consistent with other Win functions; i.e. WinTitle, WinText, ExcludeTitle, ExcludeText are always grouped together (at the end of the parameter list), to aide memorisation.

The WinTitle parameter of various functions can now accept a HWND (must be a pure integer) or an object with a Hwnd property, such as a Gui object. DetectHiddenWindows is ignored in such cases.

WinMove no longer has special handling for the literal word DEFAULT. Omit the parameter or specify an empty string instead (this works in both v1 and v2).

WinWait, WinWaitClose, WinWaitActive and WinWaitNotActive return non-zero if the wait finished (timeout did not expire). ErrorLevel was removed. WinWait and WinWaitActive return the HWND of the found window. WinWaitClose now sets the Last Found Window, so if WinWaitClose times out, it returns false and WinExist() returns the last window it found. For the timeout, specifying 0 is no longer the same as specifying 0.5; instead, it produces the shortest wait possible.

Unsorted:

A negative StartingPos for InStr, SubStr, RegExMatch and RegExReplace is interpreted as a position from the end. Position -1 is the last character and position 0 is invalid (whereas in v1, position 0 was the last character).

Functions which previously accepted On/Off or On/Off/Toggle (but not other strings) now require 1/0/-1 instead. On and Off would typically be replaced with True and False. Variables which returned On/Off now return 1/0, which are more useful in expressions.

#UseHook and #MaxThreadsBuffer allow 1, 0, True and False. (Unlike the others, they do not actually support expressions.)
ListLines allows blank or boolean.
ControlSetChecked, ControlSetEnabled, Pause, Suspend, WinSetAlwaysOnTop, and WinSetEnabled allow 1, 0 and -1.
A_DetectHiddenWindows, A_DetectHiddenText, and A_StoreCapsLockMode use boolean (as do the corresponding functions).

  
HWNDs and styles are always returned as pure integers, not hexadecimal strings.

ControlChooseIndex allows 0 to deselect the current item/all items. It replaces "Control Choose", but also supports Tab controls.

"ControlGet Tab" was merged into ControlGetIndex, which also works with ListBox, ComboBox and DDL. For Tab controls, it returns 0 if no tab is selected (rare but valid). ControlChooseIndex does not permit 0 for Tab controls since applications tend not to handle it.

ControlGetItems replaces "ControlGet List" for ListBox and ComboBox. It returns an Array.

DriveEject and DriveRetract now use DeviceIoControl instead of mciSendString. DriveEject is therefore able to eject non-CD/DVD drives which have an "Eject" option in Explorer (i.e. removable drives but not external hard drives which show as fixed disks).

ListViewGetContent replaces "ControlGet List" for ListView, and currently has the same usage as before.

WinGetList, WinGetControls and WinGetControlsHwnd return arrays, not newline-delimited lists.

WinSetTransparent treats "" as "Off" rather than 0 (which would make the window invisible and unclickable).

Abbreviated aliases such as Topmost, Trans, FS and Cap were removed. 
________________________________________________________________________
!Important ChatGPT Bing!
Concepts and Conventions
This document covers some general concepts and conventions used by AutoHotkey, with focus on explanation rather than code. The reader is not assumed to have any prior knowledge of scripting or programming, but should be prepared to learn new terminology.

For more specific details about syntax, see Scripting Language.
 
A value is simply a piece of information within a program. For example, the name of a key to send or a program to run, the number of times a hotkey has been pressed, the title of a window to activate, or whatever else has some meaning within the program or script.

AutoHotkey supports these types of values:

Strings (text)
Numbers (integers and floating-point numbers)
Objects
The Type function can be used to determine the type of a value.

Some other related concepts:

Boolean
Nothing
Strings
A string is simply text. Each string is actually a sequence or string of characters, but can be treated as a single entity. The length of a string is the number of characters in the sequence, while the position of a character in the string is merely that character's sequential number. By convention in AutoHotkey, the first character is at position 1.

Numeric strings: A string of digits (or any other supported number format) is automatically interpreted as a number when a math operation or comparison requires it.

How literal text should be written within the script depends on the context. For instance, in an expression, strings must be enclosed in quotation marks. In directives (excluding #HotIf) and auto-replace hotstrings, quotation marks are not needed.

For a more detailed explanation of how strings work, see String Encoding.

Numbers
AutoHotkey supports these number formats:

Decimal integers, such as 123, 00123 or -1.
Hexadecimal integers, such as 0x7B, 0x007B or -0x1.
Decimal floating-point numbers, such as 3.14159.
Hexadecimal numbers must use the 0x or 0X prefix, except where noted in the documentation. This prefix must be written after the + or - sign, if present, and before any leading zeroes. For example, 0x001 is valid, but 000x1 is not.

Numbers written with a decimal point are always considered to be floating-point, even if the fractional part is zero. For example, 42 and 42.0 are usually interchangeable, but not always. Scientific notation is also recognized (e.g. 1.0e4 and -2.1E-4), but always produces a floating-point number even if no decimal point is present.

The decimal separator is always a dot, even if the user's regional settings specify a comma.

When a number is converted to a string, it is formatted as decimal. Floating-point numbers are formatted with full precision (but discarding redundant trailing zeroes), which may in some cases reveal their inaccuracy. Use the Format function to produce a numeric string in a different format. Floating-point numbers can also be formatted by using the Round function.

For details about the range and accuracy of numeric values, see Pure Numbers.

Boolean
A boolean value can be either true or false. Boolean values are used to represent anything that has exactly two possible states, such as the truth of an expression. For example, the expression (x <= y) is true when x has lesser or equal value to y. A boolean value could also represent yes or no, on or off, down or up (such as for GetKeyState) and so on.

AutoHotkey does not have a specific boolean type, so it uses the integer value 0 to represent false and 1 to represent true. When a value is required to be either true or false, a blank or zero value is considered false and all other values are considered true. (Objects are always considered true.)

The words true and false are built-in variables containing 1 and 0. They can be used to make a script more readable.

Nothing
AutoHotkey does not have a value which uniquely represents nothing, null, nil or undefined, as seen in other languages.

Instead of producing a "null" or "undefined" value, any attempt to read a variable, property, array element or map item which has no value causes an UnsetError to be thrown. This allows errors to be identified more easily than if a null value was implicitly allowed to propagate through the code. See also: Uninitialized Variables.

A function's optional parameters can be omitted when the function is called, in which case the function may change its behaviour or use a default value. Parameters are usually omitted by literally omitting them from the code, but can also be omitted explicitly or conditionally by using the unset keyword. This special signal can only be propagated explicitly, with the maybe operator (var?). An unset parameter automatically receives its default value (if any) before the function executes.

Mainly for historical reasons, an empty string is sometimes used wherever a null or undefined value would be used in other languages, such as for functions which have no explicit return value.

If a variable or parameter is said to be "empty" or "blank", that usually means an empty string (a string of zero length). This is not the same as omitting a parameter, although it may have the same effect in some cases.

Objects
The object is AutoHotkey's composite or abstract data type. An object can be composed of any number of properties (which can be retrieved or set) and methods (which can be called). The name and effect of each property or method depends on the specific object or type of object.

Objects have the following attributes:

Objects are not contained; they are referenced. For example, alpha := [] creates a new Array and stores a reference in alpha. bravo := alpha copies the reference (not the object) to bravo, so both refer to the same object. When an array or variable is said to contain an object, what it actually contains is a reference to the object.
Two object references compare equal only if they refer to the same object.
Objects are always considered true when a boolean value is required, such as in if obj, !obj or obj ? x : y.
Each object has a unique address (location in memory), which can be retrieved by the ObjPtr function, but is typically not used directly. This address uniquely identifies the object, but only until the object is freed.
In some cases when an object is used in a context where one was not expected, it might be treated as an empty string. For example, MsgBox(myObject) shows an empty MsgBox. In other cases, a TypeError may be thrown (and this should become the norm in future).
Note: All objects which derive from Object have additional shared behaviour, properties and methods.

Some ways that objects are used include:
 
Object Protocol
This section builds on these concepts which are covered in later sections: variables, functions

Objects work through the principle of message passing. You don't know where an object's code or variables actually reside, so you must pass a message to the object, like "give me foo" or "go do bar", and rely on the object to respond to the message. Objects in AutoHotkey support the following basic messages:

Get a property.
Set a property, denoted by :=.
Call a method, denoted by ().
A property is simply some aspect of the object that can be set and/or retrieved. For example, Array has a Length property which corresponds to the number of elements in the array. If you define a property, it can have whatever meaning you want. Generally a property acts like a variable, but its value might be calculated on demand and not actually stored anywhere.

Each message contains the following, usually written where the property or method is called:

The name of the property or method.
Zero or more parameters which may affect what action is carried out, how a value is stored, or which value is returned. For example, a property might take an array index or key.
For example:

myObj.methodName(arg1)
value := myObj.propertyName[arg1]
An object may also have a default property, which is invoked when square brackets are used without a property name. For example:

value := myObj[arg1]
Generally, Set has the same meaning as an assignment, so it uses the same operator:

myObj.name := value
myObj.name[arg1, arg2, ..., argN] := value
myObj[arg1, arg2, ..., argN] := value
Variables
 
In AutoHotkey, variables are created simply by using them. Each variable is not permanently restricted to a single data type, but can instead hold a value of any type: string, number or object. Attempting to read a variable which has not been assigned a value is considered an error, so it is important to initialize variables.

A variable has three main aspects:

The variable's name.
The variable itself.
The variable's value.
Certain restrictions apply to variable names - see Names for details. In short, it is safest to stick to names consisting of ASCII letters (which are case insensitive), digits and underscore, and to avoid using names that start with a digit.

   
IsSet can be used to determine whether a variable has been initialized, such as to initialize a global or static variable on first use.

A variable can be un-set by combining a direct assignment (:=) with the unset keyword or the maybe (var?) operator. For example: Var := unset, Var1 := (Var2?).

The or-maybe operator (??) can be used to provide a default value when a variable lacks a value. For example, MyVar ?? "Default" is equivalent to IsSet(MyVar) ? MyVar : "Default".

Built-in Variables
 Environment Variables
Environment variables are maintained by the operating system. You can see a list of them at the command prompt by typing SET then pressing Enter.

A script may create a new environment variable or change the contents of an existing one with EnvSet. Such additions and changes are not seen by the rest of the system. However, any programs or scripts which the script launches by calling Run or RunWait usually inherit a copy of the parent script's environment variables.

To retrieve an environment variable, use EnvGet. For example:

Path := EnvGet("PATH")
Variable References (VarRef)
Within an expression, each variable reference is automatically resolved to its contents, unless it is the target of an assignment or the reference operator (&). In other words, calling myFunction(myVar) would pass the value of myVar to myFunction, not the variable itself. The function would then have its own local variable (the parameter) with the same value as myVar, but would not be able to assign a new value to myVar. In short, the parameter is passed by value.

The reference operator (&) allows a variable to be handled like a value. &myVar produces a VarRef, which can be used like any other value: assigned to another variable or property, inserted into an array, passed to or returned from a function, etc. A VarRef can be used to assign to the original target variable or retrieve its value by dereferencing it.

For convenience, a function parameter can be declared ByRef by prefixing the parameter name with ampersand (&). This requires the caller to pass a VarRef, and allows the function itself to "dereference" the VarRef by just referring to the parameter (without percent signs).

class VarRef extends Any
The VarRef class currently has no predefined methods or properties, but value is VarRef can be used to test if a value is a VarRef.
 
ControlSend "^{Home}", "Edit1", "A"  ; Correct. Control is specified.
ControlSend "^{Home}", "A"           ; Incorrect: Parameters are mismatched.
ControlSend "^{Home}",, "A"          ; Correct. Control is omitted.
Methods
A method is a function associated with a specific object or type of object. To call a method, one must specify an object and a method name. The method name does not uniquely identify the function; instead, what happens when the method call is attempted depends on the object. For example, x.Show() might show a menu, show a GUI, raise an error or do something else, depending on what x is. In other words, a method call simply passes a message to the object, instructing it to do something. For details, see Object Protocol and Operators for Objects.

Control Flow
Control flow is the order in which individual statements are executed. Normally statements are executed sequentially from top to bottom, but a control flow statement can override this, such as by specifying that statements should be executed repeatedly, or only if a certain condition is met.

Statement
A statement is simply the smallest standalone element of the language that expresses some action to be carried out. In AutoHotkey, statements include assignments, function calls and other expressions. However, directives, double-colon hotkey and hotstring tags, and declarations without assignments are not statements; they are processed when the program first starts up, before the script executes.

Execute
Carry out, perform, evaluate, put into effect, etc. Execute basically has the same meaning as in non-programming speak.

Body
The body of a control flow statement is the statement or group of statements to which it applies. For example, the body of an if statement is executed only if a specific condition is met.

For example, consider this simple set of instructions:

Open Notepad
Wait for Notepad to appear on the screen
Type "Hello, world!"
We take one step at a time, and when that step is finished, we move on to the next step. In the same way, control in a program or script usually flows from one statement to the next statement. But what if we want to type into an existing Notepad window? Consider this revised set of instructions:
 
Library

!Important ChatGPT Bing end!


!Important ChatGPT Bing Start!
!List of expression in autohotkey v2!



Operator	Description
%Expr%	
Dereference or name substitution.

When Expr evaluates to a VarRef, %Expr% accesses the corresponding variable. For example, x := &y takes a reference to y and assigns it to x, then %x% := 1 assigns to the variable y and %x% reads its value.

Otherwise, the value of the sub-expression Expr is used as the name or partial name of a variable or property. This allows the script to refer to a variable or property whose name is determined by evaluating Expr, which is typically another variable. Variables cannot be created dynamically, but a variable can be assigned dynamically if it has been declared or referenced non-dynamically somewhere in the script.

Note: The result of the sub-expression Expr must be the name or partial name of the variable or property to be accessed.

Percent signs cannot be used directly within Expr due to ambiguity, but can be nested within parentheses. Otherwise, Expr can be any expression.

If there are any adjoining %Expr% sequences and partial names (without any spaces or other characters between them), they are combined to form a single name.

An Error is typically thrown if the variable does not already exist, or if it is uninitialized and its value is being read. The or-maybe operator (??) can be used to avoid that case by providing a default value. For example: %'novar'% ?? 42.

Although this is historically known as a "double-deref", this term is inaccurate when Expr does not contain a variable (first deref), and also when the resulting variable is the target of an assignment, not being dereferenced (second deref).

x.y
x.%z%	Member access. Get or set a value or call a method of object x, where y is a literal name and z is an expression which evaluates to a name. See object syntax.
var?	
Maybe. Permits the variable to be unset. This is valid only when passing a variable to an optional parameter, array element or object literal; or on the right-hand side of a direct assignment. The question mark must be followed by one of the following symbols (ignoring whitespace): )]},:. The variable may be passed conditionally via the ternary operator or on the right-hand side of AND/OR.

The variable is typically an optional parameter, but can be any variable. For variables that are not function parameters, a VarUnset warning may still be shown at load-time if there are other references to the variable but no assignments.

This operator is currently supported only for variables. To explicitly or conditionally omit a parameter in more general cases, use the unset keyword.

See also: unset (Optional Parameters)

++
--	
Pre- and post-increment/decrement. Adds or subtracts 1 from a variable. The operator may appear either before or after the variable's name. If it appears before the name, the operation is performed and its result is used by the next operation (the result is a variable reference in this case). For example, Var := ++X increments X and then assigns its value to Var. Conversely, if the operator appears after the variable's name, the result is the value of X prior to performing the operation. For example, Var := X++ increments X but Var receives the value X had before it was incremented.

These operators can also be used with a property of an object, such as myArray.Length++ or --myArray[i]. In these cases, the result of the sub-expression is always a number, not a variable reference.

**	
Power. Example usage: base**exponent. Both base and exponent may contain a decimal point. If exponent is negative, the result will be formatted as a floating point number even if base and exponent are both integers. Since ** is of higher precedence than unary minus, -2**2 is evaluated like -(2**2) and so yields -4. Thus, to raise a literal negative number to a power, enclose it in parentheses such as (-2)**2.

The power operator is right-associative. For example, x ** y ** z is evaluated as x ** (y ** z).

Note: A negative base combined with a fractional exponent such as (-2)**0.5 is not supported; attempting it will cause an exception to be thrown. But both (-2)**2 and (-2)**2.0 are supported. If both base and exponent are 0, the result is undefined and an exception is thrown.

-
!
~
&	
Unary minus (-): Inverts the sign of its operand.

Unary plus (+): +N is equivalent to -(-N). This has no effect when applied to a pure number, but can be used to convert numeric strings to pure numbers.

Logical-not (!): If the operand is blank or 0, the result of applying logical-not is 1, which means "true". Otherwise, the result is 0 (false). For example: !x or !(y and z). Note: The word NOT is synonymous with ! except that ! has a higher precedence. Consecutive unary operators such as !!Var are allowed because they are evaluated in right-to-left order.

Bitwise-not (~): This inverts each bit of its operand. As 64-bit signed integers are used, a positive input value will always give a negative result and vice versa. For example, ~0xf0f evaluates to -0xf10 (-3856), which is binary equivalent to 0xfffffffffffff0f0. If an unsigned 32-bit value is intended, the result can be truncated with result & 0xffffffff. If the operand is a floating point value, a TypeError is thrown.

Reference (&): Creates a VarRef, which is a value representing a reference to a variable. A VarRef can then be used to indirectly access the target variable. For example, ref := &target followed by %ref% := 1 would assign the value 1 to target. The VarRef would typically be passed to a function, but could be stored in an array or property. See also: Dereference, ByRef.

Taking a reference to a built-in variable such as A_Clipboard is currently not supported, except when being passed directly to an OutputVar parameter of a built-in function.

*
/
//	
Multiply (*): The result is an integer if both inputs are integers; otherwise, it is a floating point number.

Other uses: The asterisk (*) symbol is also used in variadic function calls.

True divide (/): True division yields a floating point result even when both inputs are integers. For example, 3/2 yields 1.5 rather than 1, and 4/2 yields 2.0 rather than 2.

Integer divide (//): The double-slash operator uses high-performance integer division. For example, 5//3 is 1 and 5//-3 is -1. If either of the inputs is in floating point format, a TypeError is thrown. For modulo, see Mod.

The *= and /= operators are a shorthand way to multiply or divide the value in a variable by another value. For example, Var*=2 produces the same result as Var:=Var*2 (though the former performs better).

Division by zero causes a ZeroDivisionError to be thrown.

+
-	
Add (+) and subtract (-). On a related note, the += and -= operators are a shorthand way to increment or decrement a variable. For example, Var+=2 produces the same result as Var:=Var+2 (though the former performs better). Similarly, a variable can be increased or decreased by 1 by using Var++, Var--, ++Var, or --Var.

Other uses: If the + or - symbol is not preceded by a value (or a sub-expression which yields a value), it is interpreted as a unary operator instead.

<<
>>
>>>	
Bit shift left (<<). Example usage: Value1 << Value2. This is equivalent to multiplying Value1 by "2 to the Value2th power".

Arithmetic bit shift right (>>). Example usage: Value1 >> Value2. This is equivalent to dividing Value1 by "2 to the Value2th power" and rounding the result to the nearest integer leftward on the number line; for example, -3>>1 is -2.

Logical bit shift right (>>>). Example usage: Value1 >>> Value2. Unlike arithmetic bit shift right, this does not preserve the sign of the number. For example, -1 has the same bit representation as the unsigned 64-bit integer 0xffffffffffffffff, therefore -1 >>> 1 is 0x7fffffffffffffff.

The following applies to all three operators:

If either of the inputs is a floating-point number, a TypeError is thrown.
If Value2 is less than 0 or greater than 63, an exception is thrown.
&
^
|	
Bitwise-and (&), bitwise-exclusive-or (^), and bitwise-or (|). Of the three, & has the highest precedence and | has the lowest.

If either of the inputs is a floating-point number, a TypeError is thrown.

Related: Bitwise-not (~)

.	
Concatenate. A period (dot) with at least one space or tab on each side is used to combine two items into a single string. You may also omit the period to achieve the same result (except where ambiguous such as x -y, or when the item on the right side has a leading ++ or --). When the dot is omitted, there must be at least one space or tab between the items to be merged.

Var := "The color is " . FoundColor  ; Explicit concat
Var := "The color is " FoundColor    ; Auto-concat
Sub-expressions can also be concatenated. For example: Var := "The net price is " .  Price * (1 - Discount/100).

A line that begins with a period (or any other operator) is automatically appended to the line above it.

The entire length of each input is used, even if it includes binary zero. For example, Chr(0x2010) Chr(0x0000) Chr(0x4030) produces the following string of bytes (due to UTF-16-LE encoding): 0x10, 0x20, 0, 0, 0x30, 0x40. The result has an additional null-terminator (binary zero) which is not included in the length.

Other uses: If there is no space or tab to the right of a period (dot), it is interpreted as either a literal floating-point number or member access. For example, 1.1 and (.5) are numbers, A_Args.Has(3) is a method call and A_Args.Length is a property access.

~=	Shorthand for RegExMatch. For example, the result of "abc123" ~= "\d" is 4 (the position of the first numeric character).
>   <
>= <=	
Greater (>), less (<), greater-or-equal (>=), and less-or-equal (<=). The inputs are compared numerically. A TypeError is thrown if either of the inputs is not a number or a numeric string.

=
==
!=
!==	
Case-insensitive equal (=) / not-equal (!=) and case-sensitive equal (==) / not-equal (!==). The == operator behaves identically to = except when either of the inputs is not numeric (or both are strings), in which case == is always case sensitive and = is always case insensitive. The != and !== behave identically to their counterparts without !, except that the result is inverted.

The == and !== operators can be used to compare strings which contain binary zero. All other comparison operators except ~= compare only up to the first binary zero.

For case insensitive comparisons, only the ASCII letters A-Z are considered equivalent to their lowercase counterparts. To instead compare according to the rules of the current user's locale, use StrCompare and specify "Locale" for the CaseSense parameter.

IS
IN
CONTAINS	
Value is Class yields true (1) if Value is an instance of Class or false (0) otherwise. Class must be an Object with a Prototype own property, but typically the property is defined implicitly by a class definition. This operation is generally equivalent to HasBase(Value, Class.Prototype).

in and contains are reserved for future use.

NOT	Logical-NOT. Except for its lower precedence, this is the same as the ! operator. For example, not (x = 3 or y = 3) is the same as !(x = 3 or y = 3).
AND
&&	
Both of these are logical-AND. For example: x > 3 and x < 10.

In an expression where all operands resolve to True, the last operand that resolved to True is returned. Otherwise, the first operand that resolves to False is returned. Effectively, only when all operands are true, will the result be true. Boolean expressions are subject to short-circuit evaluation (left to right) in order to enhance performance.

A := 1, B := {}, C := 20, D := True, E := "String" ; All operands are truthy and will be evaluated
MsgBox(A && B && C && D && E) ; The last truthy operand is returned ("String")
A := 1, B := "", C := 0, D := False, E := "String" ; B is falsey, C and D are false
MsgBox(A && B && ++C && D && E) ; The first falsey operand is returned (""). C, D and E are not evaluated and C is never incremented
A line that begins with AND or && (or any other operator) is automatically appended to the line above it.

OR
||	
Both of these are logical-OR. For example: x <= 3 or x >= 10.

In an expression where at least one operand resolves to True, the first operand that resolved to True is returned. Otherwise, the last operand that resolves to False is returned. Effectively, provided at least one operand is true, the result will be true. Boolean expressions are subject to short-circuit evaluation (left to right) in order to enhance performance.

A := "", B := False, C := 0, D := "String", E := 20 ; At least one operand is truthy. All operands up until D (including) will be evaluated
MsgBox(A || B || C || D || ++E) ; The first truthy operand is returned ("String"). E is not evaluated and is never incremented
A := "", B := False, C := 0 ; All operands are falsey and will be evaluated
MsgBox(A || B || C) ; The last falsey operand is returned (0)
A line that begins with OR or || (or any other operator) is automatically appended to the line above it.

??	
Or maybe, otherwise known as the coalescing operator. If the left operand (which must be a variable) has a value, it becomes the result and the right branch is skipped. Otherwise, the right operand becomes the result. In other words, A ?? B behaves like A || B (logical-OR) except that the condition is IsSet(A).

This is typically used to provide a default value when it is known that a variable or optional parameter might not already have a value. For example:

MsgBox MyVar ?? "Default value"
Since the variable is expected to sometimes be uninitialized, no error is thrown in that case. Unlike IsSet(A) ? A : B, a VarUnset warning may still be shown at load-time if there are other references to the variable but no assignments.

?:	
Ternary operator. This operator is a shorthand replacement for the if-else statement. It evaluates the condition on its left side to determine which of its two branches should become its final result. For example, var := x>y ? 2 : 3 stores 2 in Var if x is greater than y; otherwise it stores 3. To enhance performance, only the winning branch is evaluated (see short-circuit evaluation).

See also: maybe (var?), or-maybe (??)

Note: When used at the beginning of a line, the ternary condition should usually be enclosed in parentheses to reduce ambiguity with other types of statements. For details, see Expression Statements.

:=
+=
-=
*=
/=
//=
.=
|=
&=
^=
>>=
<<=
>>>=	
Assign. Performs an operation on the contents of a variable and stores the result back in the same variable. The simplest assignment operator is colon-equals (:=), which stores the result of an expression in a variable. For a description of what the other operators do, see their related entries in this table. For example, Var //= 2 performs integer division to divide Var by 2, then stores the result back in Var. Similarly, Var .= "abc" is a shorthand way of writing Var := Var . "abc".

Unlike most other operators, assignments are evaluated from right to left. Consequently, a line such as Var1 := Var2 := 0 first assigns 0 to Var2 then assigns Var2 to Var1.

If an assignment is used as the input for some other operator, its value is the variable itself. For example, the expression (Var+=2) > 50 is true if the newly-increased value in Var is greater than 50. It is also valid to combine an assignment with the reference operator, as in &(Var := "initial value").

The precedence of the assignment operators is automatically raised when it would avoid a syntax error or provide more intuitive behavior. For example: not x:=y is evaluated as not (x:=y). Also, x==y && z:=1 is evaluated as x==y && (z:=1), which short-circuits when x doesn't equal y. Similarly, ++Var := X is evaluated as ++(Var := X); and Z>0 ? X:=2 : Y:=2 is evaluated as Z>0 ? (X:=2) : (Y:=2).

The target variable can be un-set by combining a direct assignment (:=) with the unset keyword or the maybe (var?) operator. For example: Var := unset, Var1 := (Var2?).

An assignment can also target a property of an object, such as myArray.Length += n or myArray[i] .= t. When assigning to a property, the result of the sub-expression is the value being assigned, not a variable reference.

() => expr	
Fat arrow function. Defines a simple function and returns a Func or Closure object. Write the function's parameter list (optionally preceded by a function name) to the left of the operator. When the function is called (via the returned reference), it evaluates the sub-expression expr and returns the result.

The following two examples are equivalent:

sumfn := Sum(a, b) => a + b
Sum(a, b) {
    return a + b
}
sumfn := Sum
In both cases, the function is defined unconditionally at the moment the script launches, but the function reference is stored in sumfn only if and when the assignment is evaluated.

If the function name is omitted and the parameter list consists of only a single parameter name, the parentheses can be omitted. The example below defines an anonymous function with one parameter a and stores its reference in the variable double:

double := a => a * 2
Variable references in expr are resolved in the same way as in the equivalent full function definition. For instance, expr may refer to an outer function's local variables (as in any nested function), in which case a new closure is created and returned each time the fat arrow expression is evaluated. The function is always assume-local, since declarations cannot be used.

Specifying a name for the function allows it to be called recursively or by other nested functions without storing a reference to the closure within itself (thereby creating a problematic circular reference). It can also be helpful for debugging, such with Func.Name or when displayed on the debugger's call stack.

Fat arrow syntax can also be used to define shorthand properties and methods.

,	
Comma (multi-statement). Commas may be used to write multiple sub-expressions on a single line. This is most commonly used to group together multiple assignments or function calls. For example: x:=1, y+=2, ++index, MyFunc(). Such statements are executed in order from left to right.

Note: A line that begins with a comma (or any other operator) is automatically appended to the line above it. See also: comma performance.

Comma is also used to delimit the parameters of a function call or control flow statement. To include a multi-statement expression in a parameter list, enclose it in an extra set of parentheses. For example, MyFn((x, y)) evaluates both x and y but passes y as the first and only parameter of MyFn.

The following types of sub-expressions override precedence/order of evaluation:

Expression	Description
(expression)	
Any sub-expression enclosed in parentheses. For example, (3 + 2) * 2 forces 3 + 2 to be evaluated first.

For a multi-statement expression, the result of the last statement is returned. For example, (a := 1, b := 2, c := 3) returns 3.

Mod()
Round()
Abs()

Function call. There must be no space between the function name or expression and the open parenthesis which begins the parameter list. For details, see Function Calls.

(expression) is not necessarily required to be enclosed in parentheses, but doing so may eliminate ambiguity. For example, (x.y)() retrieves a function from a property and then calls it with no parameters, whereas x.y() would implicitly pass x as the first parameter.

(expression)()

Fn(Params*)	
Variadic function call. Params is an enumerable object (an object with an __Enum method), such as an Array containing parameter values.

x[y]
[a, b, c]	
Item access. Get or set the __Item property (or default property) of object x with the parameter y (or multiple parameters in place of y). This typically corresponds to an array element or item within a collection, where y is the item's index or key. The item can be assigned a value by using any assignment operator immediately after the closing bracket. For example, x[y] := z.

Array literal. If the open-bracket is not preceded by a value (or a sub-expression which yields a value), it is interpreted as the beginning of an array literal. For example, [a, b, c] is equivalent to Array(a, b, c) (a, b and c are variables).

See Arrays and Maps for common usage.

{a: b, c: d}	
Object literal. Create an Object. Each pair consists of a literal property name a and a property value expression b. For example, x := {a: b} is equivalent to x := Object(), x.a := b. Base may be set within the object literal, but all other properties are set as own value properties, potentially overriding properties inherited from the base object.

To use a dynamic property name, enclose the sub-expression in percent signs. For example: {%nameVar%: valueVar}.


Performance: The comma operator is usually faster than writing separate expressions, especially when assigning one variable to another (e.g. x:=y, a:=b). Performance continues to improve as more and more expressions are combined into a single expression; for example, it may be 35% faster to combine five or ten simple expressions into a single expression.

Built-in Variables
The variables below are built into the program and can be referenced by any script.

See Built-in Variables for general information.

Table of Contents
Special Characters: A_Space, A_Tab
Script Properties: command line parameters, A_WorkingDir, A_ScriptDir, A_ScriptName, (...more...)
Date and Time: A_YYYY, A_MM, A_DD, A_Hour, A_Min, A_Sec, (...more...)
Script Settings: A_IsSuspended, A_ListLines, A_TitleMatchMode, (...more...)
User Idle Time: A_TimeIdle, A_TimeIdlePhysical, A_TimeIdleKeyboard, A_TimeIdleMouse
Hotkeys, Hotstrings, and Custom Menu Items: A_ThisHotkey, A_EndChar, (...more...)
Operating System and User Info: A_OSVersion, A_ScreenWidth, A_ScreenHeight, (...more...)
Misc: A_Clipboard, A_Cursor, A_EventInfo, (...more...)
Loop: A_Index, (...more...)
Special Characters
Variable	Description
A_Space	Contains a single space character.
A_Tab	Contains a single tab character.
Script Properties
Variable	Description
A_Args	Contains an array of command line parameters. For details, see Passing Command Line Parameters to a Script.
A_WorkingDir	
Can be used to get or set the script's current working directory, which is where files will be accessed by default. The final backslash is not included unless it is the root directory. Two examples: C:\ and C:\My Documents.

Use SetWorkingDir or assign a path to A_WorkingDir to change the working directory.

The script's working directory defaults to A_ScriptDir, regardless of how the script was launched.

A_InitialWorkingDir	The script's initial working directory, which is determined by how it was launched. For example, if it was run via shortcut -- such as on the Start Menu -- its initial working directory is determined by the "Start in" field within the shortcut's properties.
A_ScriptDir	
The full path of the directory where the current script is located. The final backslash is omitted (even for root directories).

If the script text is read from stdin rather than from file, this variable contains the initial working directory.

A_ScriptName	
Can be used to get or set the default title for MsgBox, InputBox, FileSelect, DirSelect and Gui. If not set by the script, it defaults to the file name of the current script, without its path, e.g. MyScript.ahk.

If the script text is read from stdin rather than from file, the default value is "*".

If the script is compiled or embedded, this is the name of the current executable file.

A_ScriptFullPath	
The full path of the current script, e.g. C:\Scripts\My Script.ahk

If the script text is read from stdin rather than from file, the value is "*".

If the script is compiled or embedded, this is the full path of the current executable file.

A_ScriptHwnd	The unique ID (HWND/handle) of the script's hidden main window.
A_LineNumber	
The number of the currently executing line within the script (or one of its #Include files). This line number will match the one shown by ListLines; it can be useful for error reporting such as this example: MsgBox "Could not write to log file (line number " A_LineNumber ")".

Since a compiled script has merged all its #Include files into one big script, its line numbering may be different than when it is run in non-compiled mode.

A_LineFile	
The full path and name of the file to which A_LineNumber belongs. If the script was loaded from an external file, this is the same as A_ScriptFullPath unless the line belongs to one of the script's #Include files.

If the script was compiled based on a .bin file, this is the full path and name of the current executable file, the same as A_ScriptFullPath.

If the script is embedded, A_LineFile contains an asterisk (*) followed by the resource name; e.g. *#1

A_ThisFunc	The name of the user-defined function that is currently executing (blank if none); for example: MyFunction. See also: Name property (Func)
A_AhkVersion	Contains the version of AutoHotkey that is running the script, such as 1.0.22. In the case of a compiled script, the version that was originally used to compile it is reported. The formatting of the version number allows a script to check whether A_AhkVersion is greater than some minimum version number with > or >= as in this example: if (A_AhkVersion >= "1.0.25.07"). See also: #Requires and VerCompare
A_AhkPath	
For non-compiled or embedded scripts: The full path and name of the EXE file that is actually running the current script. For example: C:\Program Files\AutoHotkey\AutoHotkey.exe

For compiled scripts based on a .bin file, the value is determined by reading the installation directory from the registry and appending "\AutoHotkey.exe". If AutoHotkey is not installed, the value is blank. The example below is equivalent:

InstallDir := RegRead("HKLM\SOFTWARE\AutoHotkey", "InstallDir", "")
AhkPath := InstallDir ? InstallDir "\AutoHotkey.exe" : ""
For compiled scripts based on an .exe file, A_AhkPath contains the full path of the compiled script. This can be used in combination with /script to execute external scripts. To instead locate the installed copy of AutoHotkey, read the registry as shown above.

A_IsCompiled	Contains 1 if the script is running as a compiled EXE and an empty string (which is considered false) if it is not.
Date and Time
Variable	Description
A_YYYY	
Current 4-digit year (e.g. 2004). Synonymous with A_Year.

Note: To retrieve a formatted time or date appropriate for your locale and language, use FormatTime() (time and long date) or FormatTime(, "LongDate") (retrieves long-format date).

A_MM	Current 2-digit month (01-12). Synonymous with A_Mon.
A_DD	Current 2-digit day of the month (01-31). Synonymous with A_MDay.
A_MMMM	Current month's full name in the current user's language, e.g. July
A_MMM	Current month's abbreviation in the current user's language, e.g. Jul
A_DDDD	Current day of the week's full name in the current user's language, e.g. Sunday
A_DDD	Current day of the week's abbreviation in the current user's language, e.g. Sun
A_WDay	Current 1-digit day of the week (1-7). 1 is Sunday in all locales.
A_YDay	Current day of the year (1-366). The value is not zero-padded, e.g. 9 is retrieved, not 009. To retrieve a zero-padded value, use the following: FormatTime(, "YDay0").
A_YWeek	Current year and week number (e.g. 200453) according to ISO 8601. To separate the year from the week, use Year := SubStr(A_YWeek, 1, 4) and Week := SubStr(A_YWeek, -2). Precise definition of A_YWeek: If the week containing January 1st has four or more days in the new year, it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1.
A_Hour	Current 2-digit hour (00-23) in 24-hour time (for example, 17 is 5pm). To retrieve 12-hour time as well as an AM/PM indicator, follow this example: FormatTime(, "h:mm:ss tt")
A_Min	
Current 2-digit minute (00-59).

A_Sec	Current 2-digit second (00-59).
A_MSec	Current 3-digit millisecond (000-999). To remove the leading zeros, follow this example: Milliseconds := A_MSec + 0.
A_Now	
The current local time in YYYYMMDDHH24MISS format.

Note: Date and time math can be performed with DateAdd and DateDiff. Also, FormatTime can format the date and/or time according to your locale or preferences.

A_NowUTC	The current Coordinated Universal Time (UTC) in YYYYMMDDHH24MISS format. UTC is essentially the same as Greenwich Mean Time (GMT).
A_TickCount	
The number of milliseconds that have elapsed since the system was started, up to 49.7 days. By storing A_TickCount in a variable, elapsed time can later be measured by subtracting that variable from the latest A_TickCount value. For example:

StartTime := A_TickCount
Sleep 1000
ElapsedTime := A_TickCount - StartTime
MsgBox ElapsedTime " milliseconds have elapsed."
If you need more precision than A_TickCount's 10ms, use QueryPerformanceCounter().

Script Settings
Variable	Description
A_IsSuspended	Contains 1 if the script is suspended and 0 otherwise.
A_IsPaused	Contains 1 if the thread immediately underneath the current thread is paused. Otherwise it contains 0.
A_IsCritical	Contains 0 if Critical is off for the current thread. Otherwise it contains an integer greater than zero, namely the message-check frequency being used by Critical. The current state of Critical can be saved and restored via Old_IsCritical := A_IsCritical followed later by A_IsCritical := Old_IsCritical.
A_ListLines	Can be used to get or set whether to log lines. Possible values are 0 (disabled) and 1 (enabled). For details, see ListLines.
A_TitleMatchMode	Can be used to get or set the title match mode. Possible values are 1, 2, 3 and RegEx. For details, see SetTitleMatchMode.
A_TitleMatchModeSpeed	Can be used to get or set the title match speed. Possible values are Fast and Slow. For details, see SetTitleMatchMode.
A_DetectHiddenWindows	Can be used to get or set whether to detect hidden windows. Possible values are 0 (disabled) and 1 (enabled). For details, see DetectHiddenWindows.
A_DetectHiddenText	Can be used to get or set whether to detect hidden text in a window. Possible values are 0 (disabled) and 1 (enabled). For details, see DetectHiddenText.
A_FileEncoding	Can be used to get or set the default encoding for various built-in functions. For details, see FileEncoding.
A_SendMode	Can be used to get or set the send mode. Possible values are Event, Input, Play and InputThenPlay. For details, see SendMode.
A_SendLevel	Can be used to get or set the send level, an integer from 0 to 100. For details, see SendLevel.
A_StoreCapsLockMode	Can be used to get or set whether to restore the state of CapsLock after a Send. Possible values are 0 (disabled) and 1 (enabled). For details, see SetStoreCapsLockMode.
A_KeyDelay
A_KeyDuration	Can be used to get or set the delay or duration for keystrokes, in milliseconds. For details, see SetKeyDelay.
A_KeyDelayPlay
A_KeyDurationPlay	Can be used to get or set the delay or duration for keystrokes sent via SendPlay mode, in milliseconds. For details, see SetKeyDelay.
A_WinDelay	Can be used to get or set the delay for windowing functions, in milliseconds. For details, see SetWinDelay.
A_ControlDelay	Can be used to get or set the delay for control-modifying functions, in milliseconds. For details, see SetControlDelay.
A_MenuMaskKey	Controls which key is used to mask Win or Alt keyup events. For details, see A_MenuMaskKey.
A_MouseDelay
A_MouseDelayPlay	Can be used to get or set the mouse delay, in milliseconds. A_MouseDelay is for the traditional SendEvent mode, whereas A_MouseDelayPlay is for SendPlay. For details, see SetMouseDelay.
A_DefaultMouseSpeed	Can be used to get or set the default mouse speed, an integer from 0 (fastest) to 100 (slowest). For details, see SetDefaultMouseSpeed.
A_CoordModeToolTip
A_CoordModePixel
A_CoordModeMouse
A_CoordModeCaret
A_CoordModeMenu	Can be used to get or set the area to which coordinates are to be relative. Possible values are Screen, Window and Client. For details, see CoordMode.
A_RegView	Can be used to get or set the registry view. Possible values are 32, 64 and Default. For details, see SetRegView.
A_TrayMenu	
Returns a Menu object which can be used to modify or display the tray menu.

A_AllowMainWindow	
Can be used to get or set whether the script's main window is allowed to be opened via the tray icon. Possible values are 0 (forbidden) and 1 (allowed).

If the script is neither compiled nor embedded, this variable defaults to 1, otherwise this variable defaults to 0 but can be overridden by assigning it a value. Setting it to 1 also restores the "Open" menu item to the tray menu and enables the items in the main window's View menu such as "Lines most recently executed", which allows viewing of the script's source code and other info.

The following functions are always able to show the main window and select the corresponding View options when they are encountered in the script at runtime: ListLines, ListVars, ListHotkeys, and KeyHistory.

Setting it to 1 does not prevent the main window from being shown by WinShow or inspected by ControlGetText or similar methods, but it does prevent the script's source code and other info from being exposed via the main window, except when one of the functions listed above is called by the script.

A_IconHidden	Can be used to get or set whether to hide the tray icon. Possible values are 0 (visible) and 1 (hidden). For details, see #NoTrayIcon.
A_IconTip	
Can be used to get or set the tray icon's tooltip text, which is displayed when the mouse hovers over it. If blank, the script's name is used instead.

To create a multi-line tooltip, use the linefeed character (`n) in between each line, e.g. "Line1`nLine2". Only the first 127 characters are displayed, and the text is truncated at the first tab character, if present.

On Windows 10 and earlier, to display tooltip text containing ampersands (&), escape each ampersand with two additional ampersands. For example, assigning "A &&& B" would display "A & B" in the tooltip.

A_IconFile	Blank unless a custom tray icon has been specified via TraySetIcon -- in which case it is the full path and name of the icon's file.
A_IconNumber	Blank if A_IconFile is blank. Otherwise, it's the number of the icon in A_IconFile (typically 1).
User Idle Time
Variable	Description
A_TimeIdle	The number of milliseconds that have elapsed since the system last received keyboard, mouse, or other input. This is useful for determining whether the user is away. Physical input from the user as well as artificial input generated by any program or script (such as the Send or MouseMove functions) will reset this value back to zero. Since this value tends to increase by increments of 10, do not check whether it is equal to another value. Instead, check whether it is greater or less than another value. For example:
if A_TimeIdle > 600000
    MsgBox "The last keyboard or mouse activity was at least 10 minutes ago."
A_TimeIdlePhysical	Similar to above but ignores artificial keystrokes and/or mouse clicks whenever the corresponding hook (keyboard or mouse) is installed; that is, it responds only to physical events. (This prevents simulated keystrokes and mouse clicks from falsely indicating that a user is present.) If neither hook is installed, this variable is equivalent to A_TimeIdle. If only one hook is installed, only its type of physical input affects A_TimeIdlePhysical (the other/non-installed hook's input, both physical and artificial, has no effect).
A_TimeIdleKeyboard	If the keyboard hook is installed, this is the number of milliseconds that have elapsed since the system last received physical keyboard input. Otherwise, this variable is equivalent to A_TimeIdle.
A_TimeIdleMouse	If the mouse hook is installed, this is the number of milliseconds that have elapsed since the system last received physical mouse input. Otherwise, this variable is equivalent to A_TimeIdle.
Hotkeys, Hotstrings, and Custom Menu Items
Variable	Description
A_ThisHotkey	
The most recently executed hotkey or non-auto-replace hotstring (blank if none), e.g. #z. This value will change if the current thread is interrupted by another hotkey or hotstring, so it is generally better to use the parameter ThisHotkey when available.

When a hotkey is first created -- either by the Hotkey function or the double-colon syntax in the script -- its key name and the ordering of its modifier symbols becomes the permanent name of that hotkey, shared by all variants of the hotkey.

When a hotstring is first created -- either by the Hotstring function or a double-colon label in the script -- its trigger string and sequence of option characters becomes the permanent name of that hotstring.

A_PriorHotkey	Same as above except for the previous hotkey. It will be blank if none.
A_PriorKey	The name of the last key which was pressed prior to the most recent key-press or key-release, or blank if no applicable key-press can be found in the key history. All input generated by AutoHotkey scripts is excluded. For this variable to be of use, the keyboard or mouse hook must be installed and key history must be enabled.
A_TimeSinceThisHotkey	The number of milliseconds that have elapsed since A_ThisHotkey was pressed. It will be blank whenever A_ThisHotkey is blank.
A_TimeSincePriorHotkey	The number of milliseconds that have elapsed since A_PriorHotkey was pressed. It will be blank whenever A_PriorHotkey is blank.
A_EndChar	The ending character that was pressed by the user to trigger the most recent non-auto-replace hotstring. If no ending character was required (due to the * option), this variable will be blank.
A_MaxHotkeysPerInterval	The maximum number of hotkeys that can be pressed within the interval defined by A_HotkeyInterval without triggering a warning dialog. For details, see A_MaxHotkeysPerInterval.
A_HotkeyInterval	The length of the interval used by A_MaxHotkeysPerInterval, in milliseconds.
A_HotkeyModifierTimeout	Affects the behavior of Send with hotkey modifiers: Ctrl, Alt, Win, and Shift. For details, see A_HotkeyModifierTimeout.
Operating System and User Info
Variable	Description
A_ComSpec	
Contains the same string as the environment's ComSpec variable. Often used with Run/RunWait. For example:

C:\Windows\system32\cmd.exe
A_Temp	
The full path and name of the folder designated to hold temporary files. It is retrieved from one of the following locations (in order): 1) the environment variables TMP, TEMP, or USERPROFILE; 2) the Windows directory. For example:

C:\Users\<UserName>\AppData\Local\Temp
A_OSVersion	
The version number of the operating system, in the format "major.minor.build". For example, Windows 7 SP1 is 6.1.7601.

Applying compatibility settings in the AutoHotkey executable or compiled script's properties causes the OS to report a different version number, which is reflected by A_OSVersion.

A_Is64bitOS	Contains 1 (true) if the OS is 64-bit or 0 (false) if it is 32-bit.
A_PtrSize	Contains the size of a pointer, in bytes. This is either 4 (32-bit) or 8 (64-bit), depending on what type of executable (EXE) is running the script.
A_Language	The system's default language, which is one of these 4-digit codes.
A_ComputerName	The name of the computer as seen on the network.
A_UserName	The logon name of the user who launched this script.
A_WinDir	The Windows directory. For example: C:\Windows
A_ProgramFiles	
The Program Files directory (e.g. C:\Program Files or C:\Program Files (x86)). This is usually the same as the ProgramFiles environment variable.

On 64-bit systems (and not 32-bit systems), the following applies:

If the executable (EXE) that is running the script is 32-bit, A_ProgramFiles returns the path of the "Program Files (x86)" directory.
For 32-bit processes, the ProgramW6432 environment variable contains the path of the 64-bit Program Files directory. On Windows 7 and later, it is also set for 64-bit processes.
The ProgramFiles(x86) environment variable contains the path of the 32-bit Program Files directory.
A_AppData	
The full path and name of the folder containing the current user's application-specific data. For example:

C:\Users\<UserName>\AppData\Roaming
A_AppDataCommon	
The full path and name of the folder containing the all-users application-specific data. For example:

C:\ProgramData
A_Desktop	
The full path and name of the folder containing the current user's desktop files. For example:

C:\Users\<UserName>\Desktop
A_DesktopCommon	
The full path and name of the folder containing the all-users desktop files. For example:

C:\Users\Public\Desktop
A_StartMenu	
The full path and name of the current user's Start Menu folder. For example:

C:\Users\<UserName>\AppData\Roaming\Microsoft\Windows\Start Menu
A_StartMenuCommon	
The full path and name of the all-users Start Menu folder. For example:

C:\ProgramData\Microsoft\Windows\Start Menu
A_Programs	
The full path and name of the Programs folder in the current user's Start Menu. For example:

C:\Users\<UserName>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs
A_ProgramsCommon	
The full path and name of the Programs folder in the all-users Start Menu. For example:

C:\ProgramData\Microsoft\Windows\Start Menu\Programs
A_Startup	
The full path and name of the Startup folder in the current user's Start Menu. For example:

C:\Users\<UserName>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
A_StartupCommon	
The full path and name of the Startup folder in the all-users Start Menu. For example:

C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
A_MyDocuments	
The full path and name of the current user's "My Documents" folder. Unlike most of the similar variables, if the folder is the root of a drive, the final backslash is not included (e.g. it would contain M: rather than M:\). For example:

C:\Users\<UserName>\Documents
A_IsAdmin	
If the current user has admin rights, this variable contains 1. Otherwise, it contains 0.

To have the script restart itself as admin (or show a prompt to the user requesting admin), use Run *RunAs. However, note that running the script as admin causes all programs launched by the script to also run as admin. For a possible alternative, see the FAQ.

A_ScreenWidth
A_ScreenHeight

The width and height of the primary monitor, in pixels (e.g. 1024 and 768).

To discover the dimensions of other monitors in a multi-monitor system, use SysGet.

To instead discover the width and height of the entire desktop (even if it spans multiple monitors), use the following example:

VirtualWidth := SysGet(78)
VirtualHeight := SysGet(79)
In addition, use SysGet to discover the work area of a monitor, which can be smaller than the monitor's total area because the taskbar and other registered desktop toolbars are excluded.

A_ScreenDPI	Number of pixels per logical inch along the screen width. In a system with multiple display monitors, this value is the same for all monitors. On most systems this is 96; it depends on the system's text size (DPI) setting. See also the GUI's -DPIScale option.
Misc.
Variable	Description
A_Clipboard	Can be used to get or set the contents of the OS's clipboard. For details, see A_Clipboard.
A_Cursor	
The type of mouse cursor currently being displayed. It will be one of the following words: AppStarting, Arrow, Cross, Help, IBeam, Icon, No, Size, SizeAll, SizeNESW, SizeNS, SizeNWSE, SizeWE, UpArrow, Wait, Unknown. The acronyms used with the size-type cursors are compass directions, e.g. NESW = NorthEast+SouthWest. The hand-shaped cursors (pointing and grabbing) are classified as Unknown.

A_EventInfo	
Contains additional information about the following events:

Mouse wheel hotkeys (WheelDown/Up/Left/Right)
OnMessage
Regular Expression Callouts
Note: Unlike variables such as A_ThisHotkey, each thread retains its own value for A_EventInfo. Therefore, if a thread is interrupted by another, upon being resumed it will still see its original/correct values in these variables.

A_EventInfo can also be set by the script, but can only accept unsigned integers within the range available to pointers (32-bit or 64-bit depending on the version of AutoHotkey).

A_LastError	
This is usually the result from the OS's GetLastError() function after the script calls certain functions, including DllCall, Run/RunWait, File/Ini/Reg functions (where documented) and possibly others. A_LastError is a number between 0 and 4294967295 (always formatted as decimal, not hexadecimal). Zero (0) means success, but any other number means the call failed. Each number corresponds to a specific error condition (to get a list, search www.microsoft.com for "system error codes"). A_LastError is a per-thread setting; that is, interruptions by other threads cannot change it.

Assigning a value to A_LastError also causes the OS's SetLastError() function to be called.

True
False	
Contain 1 and 0. They can be used to make a script more readable. For details, see Boolean Values.

These are actually keywords, not variables.
